

##### 基础编排

基础编排是对工具某一模式最简单的调用 [(注7)](#编排是什么？写编排有什么意义？) ，编排对工具的调用可以是多种多样的，以下将展示几种常用的编排写法，当然，也请工具作者按照格式写好编排注释：

````python
@annot.meta(
    desc="ICMP回环报文判断主机存活",
    params=[annot.Param("ip", "进行扫描的目标ip或ip段", holder="192.168.1.1/24")],
    cats={
        Attck: [Attck.Reconnaissance],
        BlackArch: [BlackArch.Scanner]
    }
)
async def simple(ip:str):
#async def 是异步函数的写法，simple 方法指定需传入字符串型参数 ip 供 alive_nmap_python 模式使用
	 """
    通过向目标主机发送 ICMP 回环探测报文，根据响应报文的丢弃情况、响应时间、响应内容、banner信息和特定服务关键字匹配，判断主机是否存活。
```
    await alive_nmap_python("192.168.1.1/24")
    ```
    """
    #await tool.mode(args)，将会按照指定的模式对工具进行调用，并且会等待工具执行结束，把得到的结果会先保留到mongodb，result将得到 mongodb 的一份数据集
    result = await nmap_python.alive(ip)
    #再次 await，利用.get() 方法，可以从 result 数据集中读取数据
    data = await result.get()
    print(data)
````



##### 后台执行

`await`方法默认会等待工具在容器内将命令执行结束后，才进行下一步骤，当工具执行的命令调用需要很多时间时，编排可以指定将这个调用置于后台执行`.start()`，立刻开始编排中的下一步骤：

​```python
async def background(domain:str):
    task = await nmap_python.port_os(ip)
    #假设 本次扫描 需要在容器中执行较久时间，可以将其置于后台执行，signal() 方法会将代码阻塞，等待任务执行成功之后才会返回
    await task.signal()
    #当指定后台执行后，支持在工具执行中传入信号（.signal()），如立刻中断工具在容器内的执行等
    result = await task
    #从数据库获取数据集
    print(result.get())
```



##### 多线程执行

当一个任务执行不会立刻返回结果，需要等待一段时间，且有很多类似的任务需要执行的时候，可以考虑使用多线程并行执行这些任务

编排支持多线程并发调用工具，启动任务的方法`Concurrent()`：

```python
async def concurrent():
    async with Concurrent(limit=2) as c:
    #并发执行函数 Concurrent()，其中 limit 为可选参数，为限制并发执行的任务数量，默认不限制
    # Concurrent() 函数是上面从 levrt 包引入的函数
        for i in ["talentsec.cn", "chaoxi.com"]:
            #对不同的域名并发调用 扫描
            task = c.start(nmap_python.port_os(i))
    result = await task
    docs = []
    async for doc in result.all():	#获取这次并发任务的全部数据
        docs.append(doc)
    print(docs)
```



##### 额外空间

当工具调用结束，返回数据时，我们也可以在编排层指定数据的存放位置（在数据库的存储空间），并且这种方法可以被复用：

```python
async def extra_namespace(ip:str):
    with ctx / "demo1":
    #在我们工具 Cr() 函数已经指定的命名空间 szczecin/nmap_python.port_os 下，再建立一级 demo1 的空间
        result = await nmap_python.port_os(ip)
        data = await result.get()
        print(data)

async def extra_namespace2(ip:str):
    with ctx / "demo2":
        await extra_namespace(ip)
        #复用 extra_namespace() 方法，在已经增加的额外加空间 demo1 下，再建立一级 demo2 的空间
```
