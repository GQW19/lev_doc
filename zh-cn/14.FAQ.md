## FAQ

#### 为什么更推荐在潮汐开源社区平台构建镜像？

  出于方便用户的考虑，潮汐开源社区提供自动构建镜像的服务，这样也将更便于对工具镜像安全性的审核及用户镜像空间的管理，当用户将 Dockerfile 上传至已关联的 Github 仓库，利用镜像管理自动构建后，代码中工具镜像名将以`.username.tool:tag`被调用；

  若用户使用的镜像为第三方构建，代码中工具镜像名需完整输入以被调用，如`registry.cn-hangzhou.aliyuncs.com/levkit/checkdmarc:v5`，并且需要更长的时间进行镜像安全性审查。

  工具使用需要通过调用镜像启动相应的工具容器，用户制作的镜像需要上传并公开才能供其他用户拉取使用，当然，潮汐开源社区提供的 levrt 库在工具执行前，将会对用户本地进行查询，如果用户本地存在工具需要的镜像就会直接调用，如果不存在便请求工具作者上传的镜像仓库平台，拉取工具镜像，这个过程需要网络畅通，稍等片刻。

#### 潮汐平台 python代码支持的参数类型

```python
bool 					布尔型
int 					整型
float 					单精度浮点型
str 					字符串类型
lev.core.file 			文件类型
list[lev.core.file] 	列表
```



#### 为何要在工具和编排内写好一系列注释？不写可以吗？

  首先，工具和编排内的注释有利于工具作者自身对工具调用及编排执行流程的梳理，也有利于工具及编排的使用者理解工具的用途、参数的意义及整体逻辑；其次，潮汐开源社区需要工具和编排中的规范注释以进行数据解析，用于前端显示，也会影响到工具的分类，所以，请各位工具与编排的作者按照文档提供的标准格式，写好工具与编排的注释。


#### 为何要在工具中定义原生模式（raw）？不定义可以吗？

  工具中的原生模式是为了用户在高级模式下自由使用而定义的，例如大家耳熟能详的 nmap 工具，nmap 在命令行调用的时候，可以附加多种参数，如`-sP -sn`等，如果将这些参数全部定义成 nmap 的模式的话会十分不便于工具作者编写与用户调用，而在原生调用下，用户可以直接传入`["-sP", "-sn", "192.168.1.1"]`的参数列表，就可以用ping方式扫描192.168.1.1的 ip 主机，且不进行端口扫描；当一个工具使用方式比较简单，参数较少，工具作者就可以不定义原生模式（raw），而直接把工具能用到的全部模式定义好，供用户直接快速使用。


#### entry()将覆盖ENTRYPOINT[]？

  Dockerfile 中的`ENTRYPOINT[]`可以被理解为启动 docker 容器后自动执行的一条命令，工具定义模式中的 entry() 函数里，会把这条命令替换成容器内工具该如何执行的命令。


#### 工具输出的结果数据将被如何处理？

  entry() 函数会利用

  1.`output = subprocess.checkout_put([], text=True)`在容器内调用工具执行命令，并返回命令行标准输出作为结果数据（output）；

  2.`subprocess.run([])`在容器内调用工具执行命令，通常会将结果以其他文件（如 .txt、.json ）的格式保存在容器本地。

  接下来工具作者可以使用 python 处理字符串数据的方法处理数据，形成包含所需结果数据的字典（result），再通过最后的`ctx.update(result)`，将结果数据的字典存入数据库。


#### 如何指定工具输出结果的存储位置？

  工具输出的结果被处理为字典类型后，将被存储在 MongoDB 数据库中，而数据在数据库的存储空间由 Cr( ) 中的参数值指定，如`szczecin/checkdmarc.raw:1.0`。


#### 编排是什么？写编排有什么意义？

  首先可以将编排理解为一个有目的性的任务，这个任务是需要使用工具来完成的，所以，又可以把编排理解为对工具的调度；上文介绍了多种编排的写法，同时需要指出，应该是工具为编排服务，编排是在工具之上的，一个编排可以调用多个工具，如当第一个工具在编排调度下得到输出结果后，可以通过数据库调用函数将输出的结果从数据库返回，传递给下一个工具使用。编排的编写类似于我们在使用 Python 时，大多会先导入库（工具），然后开始写程序（工具调用），以达到想要的目的。

#### 包是怎样的结构？

  `\lev.username.tool\`就是用户上传的工具、编排与模块调用的集合，整个文件夹就是将要上传到潮汐开源社区的包，包括 `tool.py`（工具模块）、`asset.py`（编排模块）及 `__init__.py`（导出模块）。


#### talentsec/lev启用了哪些配置？

  执行利用 talentsec/lev 构建环境后，将会在本地构建起 lev-mongo（mongo 数据库容器）、lev-mongo-express（mongo 数据库展示容器）、lev-agent（潮汐系统远端链接容器）、lev-rt（工具/编排执行时数据调度容器）及 lev-lemon（数据传输给潮汐开源社区平台前端显示容器）。


#### 潮汐开源社区会审查哪些内容？为什么需要进行审核？

  出于为平台自身安全与其他用户隐私安全的考虑，潮汐开源社区会对用户上传的工具包内代码（包括工具文件、编排调用及注释等）和用户工具文件中调用的镜像进行安全审查，确保用户上传的工具包代码解析后在前端无法触发恶意性行为，保证工具镜像启动后不会对用户系统执行恶意性操作。所以，工具包上传后可能需要等待一定的审核时间，才能在潮汐开源社区显示，才可被使用。

#### 数据存储与数据安全

  潮汐平台会在你的本地通过 docker 建立一个 MongoDB 数据库，然后将你每次运行的任务数据都以 json 的形式持久化到 MongoDB，你可以在使用的时候随时调取使用，潮汐平台不会私自将你的数据上传到互联网。

#### agent 作用

  在用户本地创建一个消息队列，这个消息队列中间件集成在 agent 中，存储所有的用户信息，包括用户创建的任务、任务的执行过程、状态变化等等都会存储在消息日志中。

#### 为什么编排要用异步

  潮汐平台考虑到各种用户场景，试图尽力降低用户门槛，在选择各种技术方案的时候发现，异步是针对各种应用场景时，门槛最低、效率最高、最优化的方案，且潮汐平台利用到的组件中有异步组件。

#### Cr 做了什么

  Cr() 函数会返回一个 Cr 对象，Cr对象定义了一个容器，但是还未启动容器。当执行 await 方法的时候，Cr 会在 容器内部新建一个 task，开始执行 entry() 方法中的逻辑，最后会将执行结果存入 MongoDB 中。

#### Docker 的作用

  容器化技术方便部署工具，并且提供轻量级的隔离，相对保证了工具执行时的系统环境和工具依赖的纯净，避免了不同操作系统不同环境的干扰。


## 附录：工具分类中英对照一览

```python
blackarch = {
    'webapp': 'web应用',
    'fuzzer': 'fuzzer',
    'scanner': '扫描器',
    'proxy': '代理',
    'windows': 'windows',
    'dos': '拒绝服务',
    'disassembler': '反汇编',
    'cracker': '爆破',
    'voip': '网络电话',
    'exploitation': '漏洞利用',
    'recon': '信息侦察',
    'spoof': '欺骗',
    'forensic': '取证',
    'crypto': '加解密',
    'backdoor': '后门',
    'networking': '网络流量',
    'misc': '杂项',
    'defensive': '防御',
    'wireless': '无线利用',
    'automation': '自动化',
    'sniffer': '嗅探器',
    'binary': '二进制',
    'packer': '包装器',
    'reversing': '逆向',
    'mobile': '移动电话',
    'malware': '恶意软件',
    'code-audit': '代码审计',
    'social': '社会工程',
    'honeypot': '蜜罐',
    'hardware': '硬件',
    'fingerprint': '指纹',
    'decompiler': '反编译',
    'config': '配置',
    'debugger': '调试器',
    'firmware': '固件',
    'bluetooth': '蓝牙',
    'database': '数据库',
    'automobile': '汽车CAN系统',
    'nfc': 'NFC',
    'tunnel': '隧道',
    'drone': '无人机',
    'unpacker': '解包器',
    'radio': '无线电',
    'keylogger': '键盘记录器',
    'stego': '隐写术',
    'anti-forensic': '反取证',
    'ids': '入侵检测',
    'gpu': 'GPU'
},

attck1 = {
    'Reconnaissance': '信息侦察',
    'ResourceDevelopment': '资源开发',
    'InitialAccess': '初始访问',
    'Execution': '恶意执行',
    'Persistence': '权限维持',
    'PrivilegeEscalation': '权限提升',
    'DefenseEvasion': '防御规避',
    'CredentialAccess': '凭证窃取',
    'Discovery': '环境发现',
    'LateralMovement': '横向移动',
    'Collection': '数据搜寻',
    'CommandandControl': '命令控制',
    'Exfiltration': '数据渗出',
    'Impact': '系统影响',
    'NetworkEffects': '流量拦截',
    'RemoteServiceEffects': '远程服务操控'
}

attck2 = {
    'TA0043': '信息侦察',
    'TA0042': '资源开发',
    'TA0001': '初始访问',
    'TA0002': '恶意执行',
    'TA0003': '权限维持',
    'TA0004': '权限提升',
    'TA0005': '防御规避',
    'TA0006': '凭证窃取',
    'TA0007': '环境发现',
    'TA0008': '横向移动',
    'TA0009': '数据搜寻',
    'TA0011': '命令控制',
    'TA0010': '数据渗出',
    'TA0040': '系统影响',
    'TA0038': '流量拦截',
    'TA0039': '远程服务操控'
}
```
