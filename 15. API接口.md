## API 接口

### levrt.Cr

* 构造方法

  `levrt.Cr(image, schema, host, entry, cmd, env, files, links, ports, services)`

* 接口说明：

  定义一个 docker image 对象并且返回，后续的所有任务执行都在此镜像中

* 参数列表

  | 参数名   | 类型              | 是否必传 | 说明                                                         | default | 示例                                                         |
  | -------- | ----------------- | -------- | ------------------------------------------------------------ | ------- | ------------------------------------------------------------ |
  | image    | str               | 是       | 镜像名                                                       | 无      | levkit/nmap_python:v1.0                                      |
  | schema   | str               | 否       | 所要储存数据的定义名,格式为`<namespace>/<name>@<major>.<minor>` | None    | `talentsec/nmap@1.0`                                         |
  | host     | boolean           | 否       | 是否使用 host网络模式                                        | False   |                                                              |
  | entry    | method            | 否       | 入口函数调用                                                 | None    |                                                              |
  | cmd      | list[str]         | 否       | 命令行参数                                                   | []      | ["--option", "-f"]                                           |
  | env      | list[str]         | 否       | 环境变量                                                     | []      | ["PATH=/bin", "DB_URI=..."]                                  |
  | files    | dict[ str, File ] | 否       | 挂载文件, key 为挂载的__目标绝对路径__, value 为文件内容或__本地文件路径__, | {}      | {"/etc/config.json": json.dumps(...).encode(),"/data/blob": pathlib.Path("./local_path...")} |
  | links    | dict[ str, str ]  | 否       | 主机链接别名                                                 | {}      | {"proxy": other_task.host}                                   |
  | ports    | list[int]         | 否       | 等待tcp端口可访问                                            | []      | [8000]                                                       |
  | services | dict[str, Cr]     | 否       | 所依赖的服务, 在主容器运行前启动, 并在主容器结束后销毁       | {}      | {"redis", Cr("redis:latest")}                                |

* 方法

  ```python
  class Cr:
      async def start(self) -> Task
      """
      启动一个容器, 返回对应的 Task
      """
  
      async def done(self) -> Document
      """
      启动一个容器, 并等待运行完成, 返回其结果数据的 Document
      """
  
      def __await__(self):
          return self.done().__await__()
  ```

### levrt.Task

* 构造方法

  无

* 方法

  ```python
  class Task:
      async def signal(self, signal="SIGINT"):
          """
          向主容器发动 Unix 信号
          """
  
      async def done(self) -> Document:
          """
          等待主容器运行结束
          """
  
      def __await__(self):
          return self.done().__await__()
  ```

### levrt.Document

* 构造方法

  无

* 属性

  * coll: 

    mongodb collection

  * __filters：

     dict ， 所储存数据的 _id 字段

* 方法

  ```python
  class Document:
      async def get(self, query=None, projection=None):
          """
          使用 __filters 获取对应的 document,
          基本等价于 mongodb 的查询语句 db.collection.findOne(query, projection)
          获取 document 中的数据集
          """
  ```

### levrt.lev

* 构造方法

  无

* 作用

  储存数据

* 方法

  ```python
  # 储存数据
  def set(self, data=None, **kwargs)
  ```

* 示例：

  ```python
  import levrt
  from levrt import lev
  
  
  def scan(taget: str):
      @levrt.remote
      def entry():
          issues=["Some issues"]
          # 储存数据
          lev.set(target=target, issues=issues)
      
      return Cr("...", "ts/issues@1.0", entry=entry())
  
  
  async def main():
      doc = await scan("example.com")
      assert {"target": "example.com", "issues": ["Some issues"]} == await doc.get()
      assert doc.coll.collaction_name == "ts/issues@1.0"
      # 保存在 ts/issues@1.0
  
      with lev / "example":
          example = await scan("example.com")
          # 保存在 example|ts/issues@1.0
  
      with lev / "httpbin" / "org":
          httpbin = await scan("httpbin.org")
          # 保存在 httpbin|org|ts/issues@1.0
  ```

### levrt.Concurrent

* 构造方法

  无

* 作用

  多线程执行 task

* 方法

  ```python
  class Concurrent:
      def __init__(self, limit=None)
  
      def start(self, corotine) -> asyncio.Task
  ```

* 示例

  ```python
  async def current():
      urls = [...]
  
      # 多个 scan 任务会同时运行, 但某一时刻最多只有5个任务同时运行
      async with Concurrent(limit=5) as c:
          for url in urls:
              c.start(scan(url))
  ```

  

### annot.meta

* 构造方法
  annot.meta(exports, desc, params,cats,tags,ext)

* 作用
  
  用于模式或者编排函数的描述，或者导出模块
  
* 参数说明

  | 参数名 | 类型         | 是否必传 | 说明                                    | default | 示例                                                         |
  | ------ | ------------ | -------- | --------------------------------------- | ------- | ------------------------------------------------------------ |
  | export | list         | 否       | 当前模块导出项                          | None    | [raw, alive, port_os]                                        |
  | desc   | str          | 否       | 描述                                    | ‘’      | ”检测局域网中存活的主机“                                     |
  | params | list         | 否       | 参数列表                                | []      | [annot.Param("ip", "进行扫描的目标ip", holder="192.168.1.1/24")] |
  | cats   | list \| dict | 否       | 模块或者编排分类(详情参考 14. FAQ 附录) | None    | {<br/>  Attck: [Attck.Reconnaissance],<br/>  BlackArch: [BlackArch.Scanner]<br/>} |
  | tags   | list[str]    | 否       | 工具模式或者编排的标签，用于搜索        | []      | [ 'nmap', 'scan' ]                                           |
  
* 示例

  参考 6. 构建安全工具nmap 代码
