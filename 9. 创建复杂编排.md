


## 多工具编排编写

编排作为工具的调用、任务的调度，从层次上应该是高于工具的，作为开发者用户可以在工具包中不写入工具文件`tool.py`，此时我们上传到潮汐开源社区平台的将会是一个“编排包”。

**所谓多工具编排，其实就是将多个工具处理任务，执行之后的结果交给下一个任务去执行，所以重点在于 `asset.py` ，在 `asset.py` 中定义方法，调用不同模块执行任务，然后再获取结果交给下一个任务执行。** 如果您理解了这句话，那么下面的内容会显得比较冗余，可简略的过一下

下面新建 一个 `szczecin.server` 项目，工具包目录结构为：

```bash
./lev-hub/
└── szczecin.server/
    ├── .gitignore
    ├── lev/				 # 手动创建
    │   └── szczecin/		 # 手动创建
    │       └── server/		 # 手动创建
    │           ├── asset.py # 手动创建
    │           ├── nmap.py  # # 手动创建，这里假设这个多工具编排自带 nmap 工具，这也就是 所谓的 tool.py
    │           └── __init__.py # 手动创建
    ├── pdm.lock
    ├── .pdm.toml
    ├── __package__			# python相关依赖包存放的文件夹
    └── pyproject.toml

  ...
```





### 工具加入

1. 当多工具编排想使用其他用户上传，并且以及公开发布的工具时，可以在`./username.asset`目录下执行安装潮汐开源社区公开发布工具的命令。

   对于 server 多工具编排，此处为`./szczecin.server`目录下：


```bash
# server 多工具编排还需要使用 ct01 用户公开发布的 hydra 工具
$ pdm add lev.ct01.hydra
```



### 编排编写

现在，可以开始编写`assest.py`了，编排的编写范例详情请见 [各式编排编写](#各式编排编写) ，以下用`server.py`的部分为例：

````python
from levrt import ctx, Concurrent, annot
from . import nmap	#导入编排包中写好的 nmap 工具
from lev.ct01.hydra import hydra	#导入刚安装好的潮汐开源社区公开发布工具 hydra


@annot.meta(
    desc="服务器及所在域资产安全审查",
    params=[annot.Param("server", "进行安全审查的 ip 列表", holder='["192.168.1.1/24"]')],
)
async def server_post(server:list):
    """
    攻击者利用扫描器对所给的 ip 或 ip 段进行主机发现，对存活的主机再进行开放的端口与服务扫描，并通过对服务器主机的操作系统与应用服务版本进行指纹识别，开始端口爆破与漏洞利用尝试。

    ```
    await server_post(["192.168.1.1/24"])
    ```
    """

    async with Concurrent() as c:
      for i in server:
        alive_task = c.start(nmap.alive(i, 1))

    alive_result = await alive_task
    alive = []
    async for doc in alive_result.all():
      alive.append(doc)
    	#多线程扫描 ip 段存活主机
    print(alive)
    # 下面可以先对 alive 进行数据处理，处理完毕交给 hydra 来执行下一个任务
    ...
````





## \_\_init__.py 介绍

### 模块导入

在`./lev-hub/username.tool/lev/username/tool/__init__.py`中，

此处为`./lev-hub/szczecin.nmap_python/lev/szczecin/nmap_python/__init__.py`，

进行模块的导入，把我们的工具调用与编排导入，整个文件目录将形成较完整的包结构[^8](#包是怎样的结构？)，即待上传的工具包：

```python
from levrt import annot
from . import nmap_python
from .asset import alive_nmap_python, port_os_nmap_python
__lev__ = annot.meta([nmap_python, alive_nmap_python, port_os_nmap_python])
```

```

如果是上面 无模式调用 的工具包导入，则直接导入 tool.py 中定义的 port_os 方法，代码如下：

```python
from levrt import annot
from .nmap_python import port_os
__lev__ = annot.meta([port_os])
```



### 模块导出

与工具包的工具文件与编排文件全部导出不同，编排包的`__init__.py`文件可以选择不将编排包中带有的工具导出，而只导出编排文件，此时编排包内的工具就不会开放到潮汐开源社区平台：

```python
#server（多工具编排模块导出）

from levrt import annot
from . import nmap #定义的工具可导入编排调用
from .server import server_post

#仅导出 server_post 编排
__lev__ = annot.meta([server_post])
```
