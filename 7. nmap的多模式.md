

##### 多模式工具

所谓的多模式工具，其实并不比无模式调用更复杂，在 `nmap_python.py` 文件中，无模式调用只包装了一条命令，多模式只是包装了多条命令

同样以 nmap_python 工具举例：

1. 接下来开始对工具的原生调用模式（raw）进行定义，使用原生调用模式的用户需要自己填写参数列表（arguments），通过原生模式，用户可以在潮汐开源社区的高级模式中自由调用工具[^3](#为何要在工具中定义原生模式（raw）？不定义可以吗？)。在这个模式下，工具将接收参数列表，工具作者需定义工具如何把参数与命令传入工具镜像，并将如何把得到的结果数据输出：

   ```python
   #利用 annot 修饰器，对 模式及 params（参数）进行介绍与举例，此处 raw 模式传入的参数是原生命令列表，即 annot.ARGV
   @annot.meta(desc="nmap 原生调用", params=[annot.ARGV])
   def raw(argv:list[str]) -> Cr: # 注意定义模式时需要指明各参数的参数类型，如此处的 cli 为 list（数组）
       """
       nmap 原生调用
       \``` # 此处因为md文档的特性，加上反斜杠，实际代码中不需要
       await nmap_python.raw(["-PE", "-sn", "192.168.1.1/24"])
       \```
       """
       @remote
       def entry(argv):
           import subprocess
           output = subprocess.check_output(['nmap', *argv], text=True)
           #因为输出的结果保存为 json 格式，所以可以利用 python 的 json 库，在工具容器中打开 .json 文件，读取数据
           data = {"result": output}
           #将结果数据传入数据库，因为利用 mongodb 存储，传入 mongodb 数据库的数据必须为字典类型
           ctx.update(data)

       #格式为 return Cr(".username.tool:tag", "username/tool.mode@version", entry=entry(argv))
       return Cr("registry.cn-hangzhou.aliyuncs.com/levkit/nmap_python:v1.0", "szczecin/nmap_python.raw@1.0", entry=entry(argv), host=True)
   ```



2. 接下来定义 nmap_python 工具的 alive 模式：

   ~~~python
   @annot.meta(desc="nmap ICMP回环报文判断主机存活", params=[annot.Param("ip", "进行扫描的目标ip或ip段", holder="192.168.1.1/24")])
   def alive(ip: str) -> Cr: # 注意定义模式时需要指明各参数的参数类型，如此处的 ip 为 str（字符串）
       """
       nmap ICMP回环报文判断主机存活
       ```
       await nmap_python.alive("192.168.1.1/24")
       ```
       """
       @remote
       def entry(ip):
           import subprocess
           import sys
           sys.path.append("/usr/lib/python3.9/site-packages")
           from bs4 import BeautifulSoup
           subprocess.run(['nmap', '-PE', '-sn', '-T4', '-n', '-oX', '/tmp/alive.xml', ip])
           soup = BeautifulSoup(open('/tmp/alive.xml', 'r').read(), 'html.parser')
           ip_alive = {
               'target': ip,
               'alive': []
               }
           if soup.host:
               for host in soup.find_all('host'):
                   if host.status['state'] == 'up':
                       live = host.address['addr']
                       ip_alive['alive'].append(live)
           #将结果数据传入数据库，因为利用 mongodb 存储，传入 mongodb 数据库的数据必须为字典类型
           ctx.update(ip_alive)
       return Cr("registry.cn-hangzhou.aliyuncs.com/levkit/nmap_python:v1.0", "szczecin/nmap_python.alive@1.0", entry=entry(ip), host=True)
   ~~~

3. 最后在工具代码的末尾写入要导出的工具模式及工具的名称（desc）与类型，[工具类型（cats）](#附录：工具分类中英对照一览)可直接调用`Attck`与`BlackArch`分类，单词首字母大写：

   ```python
   #工具导出模式
   __lev__ = annot.meta([raw, alive, port_os],
                         #工具名称
                        desc="nmap-更新版",
                        cats={
                            #工具分类
                            Attck: [Attck.Reconnaissance],
                            BlackArch: [BlackArch.Scanner]
                        })
   ```

4. 完整工具调用（nmap_python.py）示例：

   ```python
   """
   nmap是一个用于网络发现和安全审计的免费开源程序，用于网络扫描、服务升级计划管理以及主机或服务正常运行时间监控等任务，
   通过使用原始IP数据包来确定网络上可用的主机、这些主机提供的服务（应用程序名称和版本）、它们运行的操作系统信息、数据包过滤器/防火墙的类型等信息。
   nmap_python 镜像包含 nmap 实时更新的二进制版本，并搭配有 python 环境，对 nmap-os-db文件实时更新。
   """
   from levrt import Cr, ctx, remote, annot
   from levrt.annot.cats import Attck, BlackArch
   @annot.meta(desc="nmap 原生调用", params=[annot.ARGV])
   def raw(argv:list[str]) -> Cr:
       # demo 此处省略模式说明和示例，实际代码中不可省略
       @remote
       def entry(argv):
          pass # 此处省略具体代码
       return Cr("registry.cn-hangzhou.aliyuncs.com/levkit/nmap_python:v1.0", "szczecin/nmap_python.raw@1.0", entry=entry(argv), host=True)

   @annot.meta(desc="nmap ICMP回环报文判断主机存活", params=[annot.Param("ip", "进行扫描的目标ip或ip段", holder="192.168.1.1/24")])
   def alive(ip: str) -> Cr:
        # demo 此处省略模式说明和示例，实际代码中不可省略
       @remote
       def entry(ip):
           pass # 此处省略具体代码
       return Cr("registry.cn-hangzhou.aliyuncs.com/levkit/nmap_python:v1.0", "szczecin/nmap_python.alive@1.0", entry=entry(ip), host=True)

   @annot.meta(desc="nmap SYN扫描目标主机开放端口、主机名及操作系统", params=[annot.Param("ip", "进行扫描的目标ip或ip段", holder="192.168.1.1/24")])
   def port_os(ip: str) -> Cr:
       # demo 此处省略模式说明和示例，实际代码中不可省略
       @remote
       def entry(ip):
           # 此处省略具体代码
       return Cr("registry.cn-hangzhou.aliyuncs.com/levkit/nmap_python:v1.0", "szczecin/nmap_python.port_os@1.0", entry=entry(ip), host=True)

   #工具导出模式
   __lev__ = annot.meta([raw, alive, port_os],
                        desc="nmap-更新版",
                        cats={
                            Attck: [Attck.Reconnaissance],
                            BlackArch: [BlackArch.Scanner]
                        })
   ```





#### asset.py 介绍

asset.py 的作用在于使用编排功能

在上面的 `tool.py` 文件中定义了工具的基础调用方法，但是在实际的应用中，往往是要对结果集进行处理或者多个工具形成一个链式调用，，前一个工具的处理结果需要给到后面一个工具调用，所以有了编排功能，也就是 asset.py 文件



以下以准备对 nmap_python 工具进行编排调用为例，因为`nmap_python.py`已经定义了 raw，alive，port_os 三种模式可供调用

导入依赖包：

```python
import asyncio as aio
from levrt import ctx, annot, Concurrent
#导入 nmap_python 工具等待调用
from . import nmap_python
from levrt.annot.cats import Attck, BlackArch
```
